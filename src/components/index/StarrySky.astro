---
// No server-side javascript needed for this component based on the original svelte code.
// All logic is client-side.
---

<div class="starfield-container" transition:persist="starfield">
  <canvas class="stars-canvas" aria-hidden="true"></canvas>
</div>

<style>
  .starfield-container {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
  }

  .stars-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }
</style>

<script>
  const STAR_COUNTS = { small: 50, medium: 100, large: 30 };
  const SPEEDS = { small: 0.3, medium: 0.2, large: 0.1 };

  interface Star {
    x: number;
    y: number;
    size: number;
    speed: number;
    opacity: number;
  }

  interface StarfieldState {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    stars: Star[];
    animationId: number | null;
    isVisible: boolean;
    width: number;
    height: number;
    resizeObserver: ResizeObserver | null;
    abortController: AbortController;
  }

  let state: StarfieldState | null = null;

  const OPACITY_BUCKETS = 8;

  function createStars(width: number, height: number): Star[][] {
    const buckets: Star[][] = Array.from({ length: OPACITY_BUCKETS }, () => []);

    const addStars = (count: number, size: number, speed: number) => {
      for (let i = 0; i < count; i++) {
        const opacity = 0.3 + Math.random() * 0.7;
        const bucketIndex = Math.min(Math.floor(((opacity - 0.3) / 0.7) * OPACITY_BUCKETS), OPACITY_BUCKETS - 1);
        buckets[bucketIndex].push({ x: Math.random() * width, y: Math.random() * height, size, speed, opacity });
      }
    };

    addStars(STAR_COUNTS.small, 1, SPEEDS.small);
    addStars(STAR_COUNTS.medium, 1.5, SPEEDS.medium);
    addStars(STAR_COUNTS.large, 2, SPEEDS.large);

    return buckets;
  }

  function draw() {
    if (!state || !state.isVisible) return;

    const { ctx, stars, width, height } = state;
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = '#FFF';

    for (const bucket of stars) {
      if (bucket.length === 0) continue;

      ctx.globalAlpha = bucket[0].opacity; // representative alpha for bucket
      ctx.beginPath();
      for (const star of bucket) {
        star.y = (star.y + star.speed) % height;
        star.x = (star.x + star.speed * 0.5) % width;
        ctx.moveTo(star.x + star.size, star.y);
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
      }
      ctx.fill();
    }

    state.animationId = requestAnimationFrame(draw);
  }

  function startAnimation() {
    if (!state || state.animationId !== null) return;
    state.animationId = requestAnimationFrame(draw);
  }

  function stopAnimation() {
    if (!state || state.animationId === null) return;
    cancelAnimationFrame(state.animationId);
    state.animationId = null;
  }

  // Handle resize using ResizeObserver (no forced reflows)
  function handleResize(entries: ResizeObserverEntry[]) {
    if (!state) return;

    const entry = entries[0];
    if (!entry) return;

    // Use contentBoxSize to avoid getBoundingClientRect
    const boxSize = entry.contentBoxSize[0];
    const width = boxSize?.inlineSize ?? entry.contentRect.width;
    const height = boxSize?.blockSize ?? entry.contentRect.height;

    if (width === 0 || height === 0) return;

    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    // Batch all writes together
    state.width = width;
    state.height = height;
    state.canvas.width = width * dpr;
    state.canvas.height = height * dpr;

    // Reset and scale context
    state.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Recreate stars for new dimensions
    state.stars = createStars(width, height);
  }

  function cleanup() {
    if (!state) return;

    stopAnimation();
    state.resizeObserver?.disconnect();
    state.abortController.abort();
    state = null;
  }

  function init() {
    // Clean up any existing instance
    cleanup();

    const canvas = document.querySelector<HTMLCanvasElement>('.starfield-container .stars-canvas');
    if (!canvas) return;

    const ctx = canvas.getContext('2d', { alpha: true });
    if (!ctx) return;

    const container = canvas.parentElement;
    if (!container) return;

    const abortController = new AbortController();
    const { signal } = abortController;

    state = {
      canvas,
      ctx,
      stars: [],
      animationId: null,
      isVisible: true,
      width: 0,
      height: 0,
      resizeObserver: null,
      abortController,
    };

    // Use ResizeObserver - no forced reflows!
    const resizeObserver = new ResizeObserver(handleResize);
    resizeObserver.observe(container);
    state.resizeObserver = resizeObserver;

    // Visibility handling
    document.addEventListener(
      'visibilitychange',
      () => {
        if (!state) return;
        state.isVisible = !document.hidden;
        if (state.isVisible) {
          startAnimation();
        } else {
          stopAnimation();
        }
      },
      { signal },
    );

    // Intersection Observer for efficiency
    const intersectionObserver = new IntersectionObserver(
      (entries) => {
        if (!state) return;
        state.isVisible = entries[0]?.isIntersecting ?? false;
        if (state.isVisible) {
          startAnimation();
        } else {
          stopAnimation();
        }
      },
      { threshold: 0 },
    );
    intersectionObserver.observe(canvas);

    // Cleanup intersection observer via abort signal
    signal.addEventListener('abort', () => {
      intersectionObserver.disconnect();
    });

    // Start animation after first resize
    // ResizeObserver fires immediately, so animation starts from handleResize indirectly
    startAnimation();
  }

  // Handle Astro navigation
  document.addEventListener('astro:before-swap', cleanup);
  document.addEventListener('astro:page-load', init);

  // Initial load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init, { once: true });
  } else {
    init();
  }
</script>
