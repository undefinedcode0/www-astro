---
// unchanged imports
import DashedLine from '@/components/common/DashedLine.astro';
import FancyArrow from '@/components/icons/FancyArrow.astro';
import Link from '@/components/common/Link.astro';
import { ArrowLeft, ArrowRight } from 'astro-feather-icons2';
import ThemeSelector from '@/components/common/ThemeSelector.astro';
import FontSelector from '@/components/common/FontSelector.astro';

const gridRows = 5;
const gridCols = 20;
const totalArrows = gridRows * gridCols;

// @ts-ignore
const commit = BUILD_COMMIT;
// @ts-ignore
const date_unix = new Date(Date.parse(BUILD_DATE));
const date = date_unix.toLocaleDateString('en-US', {
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
});
---

<footer class="overflow-hidden py-12 w-full max-w-screen" transition:name="footer">
  <div id="arrow-box" data-grid-rows={gridRows} data-grid-cols={gridCols}>
    <div class="arrow-grid">
      {
        Array.from({ length: totalArrows }).map((_, i) => (
          <div class="arrow-wrapper text-text" data-index={i}>
            <FancyArrow />
          </div>
        ))
      }
    </div>
  </div>
  <DashedLine width="100%" class="my-5" />
  <div class="flex flex-col flex-wrap gap-3">
    <div style="user-select: none;" class="flex flex-wrap gap-3 items-center">
      <ThemeSelector />
      <span class="text-text/20">&bull;</span>
      <FontSelector />
    </div>
    <p class="flex flex-wrap gap-3 items-center mt-5">
      <Link href="/rss.xml">RSS</Link>
      <span class="text-text/20">&bull;</span>
      <span class="flex flex-wrap gap-3">
        <Link href="https://github.com/undefinedcode0" external>Github</Link>
        <Link href="https://bsky.app/profile/undefinedcode0.bsky.social" external>Bluesky</Link>
        <Link href="https://twitter.com/undefinedcode0" external>Twitter</Link>
      </span>
    </p>
    <p class="flex flex-col mt-5 lg:flex-row lg:gap-3">
      <span>my website </span>
      <span class="text-text/20">&bull;</span>
      <span> Built with &lt;3 and Astro </span>
      <span class="text-text/20">&bull;</span>
      <span>
        Updated <span class="font-mono text-[14px]">{date}</span>
      </span>
      <span class="text-text/20">&bull;</span>
      <span> Commit <span class="font-mono text-[14px]">{commit}</span> </span>
      <span class="text-text/20">&bull;</span>
      <Link href="https://github.com/undefinedcode0/www-astro" external class="-translate-y-px">Source</Link>
      <span class="text-text/20">&bull;</span>
      <Link
        href="https://cloud.umami.is/share/EHDxW1dO8DPxLZwL/undefinedcode.pages.dev"
        external
        class="-translate-y-px">Analytics</Link
      >
      <span class="flex gap-2 items-end sm:mr-0 sm:ml-auto">
        <p id="quote"></p>
      </span>
    </p>
  </div>
  <DashedLine width="100%" class="mt-5 mb-32" />
</footer>

<!-- quote typing script unchanged -->
<script>
  (function () {
    const QUOTE_ID = 'quote';
    const BATCH_CHARS = 5; // chars per chunk fallback (tweak)
    const IDLE_MIN_TIME = 1; // ms: leave a little headroom in requestIdleCallback
    const IDLE_TIMEOUT = 200; // requestIdleCallback timeout fallback
    const quotes = [
      'Let your worries fade in the soft embrace of a summer breeze, and let your courage bloom.',
      'As the snow falls softly on the quiet forest, so let your heart come to rest, and your spirit stand firm.',
      'When you feel it there, gain the power to persist in the whispering leaves of an ageless oak and receive the serenity to endure.',
      "Listen to courage on the quiet ripple of a mountain stream, 'Neath dawn so clear and tranquil, gain strength for a new start; gain grace to pause.",
      'In a deep, restful shade of a willow tree, allow fears to disappear and let your inner light shine.',
      'As the sun sets over a placid lake, find the peace to reflect on your journey and the courage to continue.',
      'In the distant thunder lullaby, feel the power within and the calm before every storm.',
      "At twilight's soft gleaming, may your spirit find rest and your heart lift with quiet bravery.",
      'In the gentle sway of golden fields, find the peace to breathe deeply and the strength to stand tall.',
      'Under a canopy of stars, let your dreams soarâ€”be brave enough to reach them yet peaceful enough to believe.',
      'In the silence of a snowy night, you can feel the serenity of the world and the resilience of your soul.',
      'Flow with the currents of life as the tide kisses the shore. Be grounded in calm and courage.',
      'Find in the subdued murmur of a hidden brook the symphony of nature and strength for the future.',
      'Amidst the tranquil loveliness of some sunlit meadow, let your heart be light and your spirit unyielding.',
      'Accept the night with peaceful grace, in quiet confidence under the watchful gaze of the moon.',
      'Find fleeting peace and courage to shine in the darkness in the delicate dance of fireflies.',
      'Let clarity bring you strength and peace, your soul, to ground.',
      'Hear the whisper of courage in the rustle of autumn leaves and the promise of renewal.',
      'Beneath the still surface of an azure sea, find the depths of your strength and the rest of your heart.',
    ];

    function pickRandomQuote() {
      return quotes[Math.floor(Math.random() * quotes.length)];
    }

    // rIC wrapper with fallback to setTimeout
    const ric = window.requestIdleCallback
      ? (cb, opts) => window.requestIdleCallback(cb, opts)
      : (cb, opts) => {
          // fallback: schedule after a short timeout so we don't block paint
          return setTimeout(
            () => cb({ timeRemaining: () => Infinity, didTimeout: false }),
            opts && opts.timeout ? opts.timeout : IDLE_TIMEOUT,
          );
        };

    const ricCancel = window.cancelIdleCallback ? (id) => window.cancelIdleCallback(id) : (id) => clearTimeout(id);

    function createTypingController(containerEl) {
      if (!containerEl) return null;
      containerEl.textContent = '';
      const textNode = document.createTextNode('');
      containerEl.appendChild(textNode);

      let idx = 0;
      let quote = '';
      let idleHandle = null;
      let running = false;

      function workChunk(deadline) {
        // deadline.timeRemaining() for rIC; fallback passes Infinity
        const timeLeft = typeof deadline.timeRemaining === 'function' ? deadline.timeRemaining() : Infinity;
        // if we have only tiny time left, do a small batch, otherwise allow more up to BATCH_CHARS*2
        const batchLimit = timeLeft > IDLE_MIN_TIME ? BATCH_CHARS * 2 : BATCH_CHARS;

        let didWork = false;
        let count = 0;
        while (idx < quote.length && count < batchLimit) {
          textNode.appendData(quote.charAt(idx));
          idx++;
          count++;
          didWork = true;
        }

        if (idx < quote.length) {
          // schedule next idle chunk; use a small timeout fallback via ric
          idleHandle = ric(workChunk, { timeout: IDLE_TIMEOUT });
        } else {
          running = false;
          idleHandle = null;
        }
      }

      function start(newQuote) {
        if (!newQuote) return;
        stop();
        // reset
        textNode.data = '';
        idx = 0;
        quote = newQuote;
        running = true;
        // schedule first chunk during idle
        idleHandle = ric(workChunk, { timeout: IDLE_TIMEOUT });
      }

      function stop() {
        running = false;
        if (idleHandle != null) {
          ricCancel(idleHandle);
          idleHandle = null;
        }
      }

      function isRunning() {
        return running;
      }

      return { start, stop, isRunning };
    }

    function initTyping() {
      const el = document.getElementById(QUOTE_ID);
      if (!el) return;
      const controller = createTypingController(el);
      if (!controller) return;

      // Pause typing when tab is hidden to avoid background work
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) controller.stop();
        else controller.start(pickRandomQuote());
      });

      // Stop if element removed from DOM (SPA nav)
      const observer = new MutationObserver(() => {
        if (!document.contains(el)) controller.stop();
      });
      observer.observe(document, { childList: true, subtree: true });

      // start
      controller.start(pickRandomQuote());
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initTyping);
    } else {
      initTyping();
    }
  })();
</script>

<style>
  .arrow-grid {
    display: grid;
    grid-template-columns: repeat(20, 1fr);
    grid-template-rows: repeat(5, 1fr);
    row-gap: 16px;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  .arrow-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    transform-origin: center;
  }

  .arrow-wrapper :global(svg) {
    width: 16px;
    height: 16px;
    transform-origin: center;
    /* transition: opacity 0.2s ease, color 0.2s ease; */
    opacity: 0;
  }

  @media (pointer: coarse), (hover: none), (max-width: 768px) {
    #arrow-box {
      display: none !important;
    }
  }
</style>

<script>
  let lastMouseEvent = null;
  let cachedFooterRect = null;
  let cachedArrowCenters = [];
  let rectsNeedUpdate = true;

  // animation / timing
  let animationRunning = false;
  let lastMouseMoveTime = Date.now();
  let animationFrameId = null;

  // Spring config
  const springStrength = 0.07;
  const damping = 0.8;
  const maxOffset = 40;
  const maxVelocity = 2.0;

  const footer = document.getElementById('arrow-box');
  const arrowWrappers = Array.from(document.querySelectorAll('.arrow-wrapper'));
  const arrowElements = arrowWrappers.map((w) => w.querySelector('svg'));
  const gridRowsAttr = footer?.dataset?.gridRows;
  const gridColsAttr = footer?.dataset?.gridCols;
  const gridRows = parseInt(gridRowsAttr, 10) || 5;
  const gridCols = parseInt(gridColsAttr, 10) || 20;
  const totalArrows = Math.min(gridRows * gridCols, arrowWrappers.length);

  const springs = Array.from({ length: totalArrows }).map(() => ({
    x: 0,
    y: 0,
    vx: 0,
    vy: 0,
  }));

  function updateCachedRects() {
    if (!footer) return;
    cachedFooterRect = footer.getBoundingClientRect();

    const cellW = cachedFooterRect.width / gridCols;
    const cellH = cachedFooterRect.height / gridRows;

    cachedArrowCenters = Array.from({ length: totalArrows }).map((_, i) => {
      const col = i % gridCols;
      const row = Math.floor(i / gridCols);
      return {
        x: cachedFooterRect.left + col * cellW + cellW / 2,
        y: cachedFooterRect.top + row * cellH + cellH / 2,
      };
    });

    rectsNeedUpdate = false;
  }

  let resizeTimeout = null;
  function scheduleRectsUpdate() {
    rectsNeedUpdate = true;
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      updateCachedRects();
    }, 32);
  }
  window.addEventListener('resize', scheduleRectsUpdate);
  window.addEventListener('scroll', scheduleRectsUpdate, { passive: true });

  function updateArrows(e) {
    if (!footer) return;
    if (rectsNeedUpdate) updateCachedRects();
    if (!cachedFooterRect) return;

    const mouseX = e.clientX;
    const mouseY = e.clientY;

    const isNearFooter =
      mouseY > cachedFooterRect.top - 100 &&
      mouseY < cachedFooterRect.bottom + 100 &&
      mouseX > cachedFooterRect.left - 100 &&
      mouseX < cachedFooterRect.right + 100;

    const footerCenterX = cachedFooterRect.left + cachedFooterRect.width / 2;
    const footerCenterY = cachedFooterRect.top + cachedFooterRect.height / 2;
    const distanceThreshold = Math.max(cachedFooterRect.width, cachedFooterRect.height) * 0.75;
    const distanceToCenter = Math.sqrt((mouseX - footerCenterX) ** 2 + (mouseY - footerCenterY) ** 2);

    for (let index = 0; index < totalArrows; index++) {
      const center = cachedArrowCenters[index];
      if (!center) continue;

      const arrow = arrowElements[index];
      if (!arrow) continue;

      const arrowX = center.x;
      const arrowY = center.y;

      let targetX, targetY;
      if (distanceToCenter > distanceThreshold || !isNearFooter) {
        targetX = footerCenterX;
        targetY = footerCenterY;
      } else {
        targetX = mouseX;
        targetY = mouseY;
      }

      const dx = targetX - arrowX;
      const dy = targetY - arrowY;
      const angle = Math.atan2(dy, dx) * (180 / Math.PI);
      const spring = springs[index];
      const distance = Math.sqrt(dx * dx + dy * dy);

      let nudgeDirectionX = dx;
      let nudgeDirectionY = dy;
      const dirMagnitude = Math.max(0.0001, Math.sqrt(dx * dx + dy * dy));
      nudgeDirectionX /= dirMagnitude;
      nudgeDirectionY /= dirMagnitude;
      const nudgeMagnitude = Math.min(distance * 0.05, maxOffset);
      const targetOffsetX = nudgeDirectionX * nudgeMagnitude;
      const targetOffsetY = nudgeDirectionY * nudgeMagnitude;
      const forceX = (targetOffsetX - spring.x) * springStrength;
      const forceY = (targetOffsetY - spring.y) * springStrength;

      spring.vx = spring.vx * damping + forceX;
      spring.vy = spring.vy * damping + forceY;

      const currentVelocity = Math.sqrt(spring.vx * spring.vx + spring.vy * spring.vy);
      if (currentVelocity > maxVelocity) {
        const scaleFactor = maxVelocity / currentVelocity;
        spring.vx *= scaleFactor;
        spring.vy *= scaleFactor;
      }

      spring.x += spring.vx;
      spring.y += spring.vy;

      const positionMagnitude = Math.sqrt(spring.x * spring.x + spring.y * spring.y);
      if (positionMagnitude > maxOffset) {
        const posScaleFactor = maxOffset / positionMagnitude;
        spring.x *= posScaleFactor;
        spring.y *= posScaleFactor;
      }

      const maxDistance =
        Math.sqrt(cachedFooterRect.width * cachedFooterRect.width + cachedFooterRect.height * cachedFooterRect.height) /
        1.5;
      const normalizedDistance = distance / maxDistance;
      const opacity = isNearFooter ? Math.max(0.2, 1 - Math.abs(normalizedDistance) * 2) : 0.2;

      arrow.style.transform = `translate3d(${spring.x}px, ${spring.y}px, 0) rotate(${angle}deg)`;
      arrow.style.color = `var(--color-link)`;
      arrow.style.opacity = opacity.toFixed(2);
    }
  }

  function animateArrowsLoop() {
    const now = Date.now();
    const timeSinceLastMove = now - lastMouseMoveTime;

    if (timeSinceLastMove > 2000) {
      animationRunning = false;
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      return;
    }

    const lastEvent = lastMouseEvent || {
      clientX: window.innerWidth / 2,
      clientY: window.innerHeight * 2,
    };

    updateArrows(lastEvent);

    animationFrameId = requestAnimationFrame(animateArrowsLoop);
  }

  function handleMouseMove(e) {
    lastMouseEvent = e;
    lastMouseMoveTime = Date.now();

    if (!animationRunning) {
      animationRunning = true;
      animationFrameId = requestAnimationFrame(animateArrowsLoop);
    }
  }

  document.addEventListener('mousemove', handleMouseMove);

  updateCachedRects();

  lastMouseEvent = {
    clientX: window.innerWidth / 2,
    clientY: window.innerHeight * 2,
  };
  lastMouseMoveTime = Date.now();
  animationRunning = true;
  animationFrameId = requestAnimationFrame(animateArrowsLoop);
</script>
