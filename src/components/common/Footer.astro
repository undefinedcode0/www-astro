---
// unchanged imports
import DashedLine from '@/components/common/DashedLine.astro';
import FancyArrow from '@/components/icons/FancyArrow.astro';
import Link from '@/components/common/Link.astro';
import { ArrowLeft, ArrowRight } from 'astro-feather-icons2';
import ThemeSelector from '@/components/common/ThemeSelector.astro';
import FontSelector from '@/components/common/FontSelector.astro';

const gridRows = 5;
const gridCols = 20;
const totalArrows = gridRows * gridCols;

// @ts-ignore
const commit = BUILD_COMMIT;
// @ts-ignore
const date_unix = new Date(Date.parse(BUILD_DATE));
const date = date_unix.toLocaleDateString('en-US', {
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
});
---

<footer class="overflow-hidden py-12 w-full max-w-screen" transition:name="footer">
  <!--
  <div id="arrow-box" data-grid-rows={gridRows} data-grid-cols={gridCols}>
    <div class="arrow-grid">
      {
        Array.from({ length: totalArrows }).map((_, i) => (
          <div class="arrow-wrapper text-text" data-index={i}>
            <FancyArrow />
          </div>
        ))
      }
    </div>
  </div> -->
  <DashedLine width="100%" class="my-5" />
  <div class="flex flex-col flex-wrap gap-3">
    <div style="user-select: none;" class="flex flex-wrap gap-3 items-center">
      <ThemeSelector />
      <span class="text-text/20">&bull;</span>
      <FontSelector />
    </div>
    <p class="flex flex-wrap gap-3 items-center mt-5">
      <Link href="/rss.xml">RSS</Link>
      <span class="text-text/20">&bull;</span>
      <span class="flex flex-wrap gap-3">
        <Link href="https://github.com/undefinedcode0" external>Github</Link>
        <Link href="https://bsky.app/profile/undefinedcode0.bsky.social" external>Bluesky</Link>
        <Link href="https://twitter.com/undefinedcode0" external>Twitter</Link>
      </span>
    </p>
    <p class="flex flex-col mt-5 lg:flex-row lg:gap-3">
      <span>my website </span>
      <span class="text-text/20">&bull;</span>
      <span> Built with &lt;3 and Astro </span>
      <span class="text-text/20">&bull;</span>
      <span>
        Updated <span class="font-mono text-[14px]">{date}</span>
      </span>
      <span class="text-text/20">&bull;</span>
      <span> Commit <span class="font-mono text-[14px]">{commit}</span> </span>
      <span class="text-text/20">&bull;</span>
      <Link href="https://github.com/undefinedcode0/www-astro" external class="-translate-y-px">Source</Link>
      <!-- remove for now
      <span class="text-text/20">&bull;</span>

      <Link
        href="https://cloud.umami.is/share/EHDxW1dO8DPxLZwL/undefinedcode.pages.dev"
        external
        class="-translate-y-px">Analytics</Link
      >-->
      <span class="flex gap-2 items-end sm:mr-0 sm:ml-auto">
        <p id="quote"></p>
      </span>
    </p>
  </div>
  <DashedLine width="100%" class="mt-5 mb-32" />
</footer>

<!-- quote typing script unchanged -->
<script>
  (() => {
    const quotes = [
      'Let your worries fade in the soft embrace of a summer breeze, and let your courage bloom.',
      'As the snow falls softly on the quiet forest, so let your heart come to rest, and your spirit stand firm.',
      'When you feel it there, gain the power to persist in the whispering leaves of an ageless oak and receive the serenity to endure.',
      "Listen to courage on the quiet ripple of a mountain stream, 'Neath dawn so clear and tranquil, gain strength for a new start; gain grace to pause.",
      'In a deep, restful shade of a willow tree, allow fears to disappear and let your inner light shine.',
      'As the sun sets over a placid lake, find the peace to reflect on your journey and the courage to continue.',
      'In the distant thunder lullaby, feel the power within and the calm before every storm.',
      "At twilight's soft gleaming, may your spirit find rest and your heart lift with quiet bravery.",
      'In the gentle sway of golden fields, find the peace to breathe deeply and the strength to stand tall.',
      'Under a canopy of stars, let your dreams soarâ€”be brave enough to reach them yet peaceful enough to believe.',
      'In the silence of a snowy night, you can feel the serenity of the world and the resilience of your soul.',
      'Flow with the currents of life as the tide kisses the shore. Be grounded in calm and courage.',
      'Find in the subdued murmur of a hidden brook the symphony of nature and strength for the future.',
      'Amidst the tranquil loveliness of some sunlit meadow, let your heart be light and your spirit unyielding.',
      'Accept the night with peaceful grace, in quiet confidence under the watchful gaze of the moon.',
      'Find fleeting peace and courage to shine in the darkness in the delicate dance of fireflies.',
      'Let clarity bring you strength and peace, your soul, to ground.',
      'Hear the whisper of courage in the rustle of autumn leaves and the promise of renewal.',
      'Beneath the still surface of an azure sea, find the depths of your strength and the rest of your heart.',
    ];

    function initTyping() {
      const el = document.getElementById('quote');
      if (!el) return;

      const quote = quotes[Math.floor(Math.random() * quotes.length)];
      let idx = 0;
      let frameId: number | null = null;

      // Batch updates - type multiple chars per frame
      const CHARS_PER_FRAME = 2;
      const FRAME_DELAY = 50; // ms between batches
      let lastTime = 0;

      function type(timestamp: number) {
        if (document.hidden || idx >= quote.length) {
          frameId = null;
          return;
        }

        if (timestamp - lastTime >= FRAME_DELAY) {
          const end = Math.min(idx + CHARS_PER_FRAME, quote.length);
          el.textContent += quote.slice(idx, end);
          idx = end;
          lastTime = timestamp;
        }

        frameId = requestAnimationFrame(type);
      }

      // Start typing
      frameId = requestAnimationFrame(type);

      // Pause when hidden
      const handleVisibility = () => {
        if (document.hidden && frameId) {
          cancelAnimationFrame(frameId);
          frameId = null;
        } else if (!document.hidden && idx < quote.length) {
          frameId = requestAnimationFrame(type);
        }
      };
      document.addEventListener('visibilitychange', handleVisibility);

      // Cleanup
      return () => {
        if (frameId) cancelAnimationFrame(frameId);
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    }

    let cleanup: (() => void) | undefined;

    function init() {
      cleanup?.();
      cleanup = initTyping();
    }

    init();
    document.addEventListener('astro:page-load', init);
    document.addEventListener('astro:before-swap', () => cleanup?.());
  })();
</script>

<!-- remove for now (unsure)
<style>
  .arrow-grid {
    display: grid;
    grid-template-columns: repeat(20, 1fr);
    grid-template-rows: repeat(5, 1fr);
    row-gap: 16px;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  .arrow-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    transform-origin: center;
  }

  .arrow-wrapper :global(svg) {
    width: 16px;
    height: 16px;
    transform-origin: center;
    /* transition: opacity 0.2s ease, color 0.2s ease; */
    opacity: 0;
  }

  @media (pointer: coarse), (hover: none), (max-width: 768px) {
    #arrow-box {
      display: none !important;
    }
  }
</style>

<script>
  const footer = document.getElementById('arrow-box');
  if (!footer) throw new Error('arrow-box not found');

  const arrowWrappers = Array.from(document.querySelectorAll('.arrow-wrapper'));
  const arrowElements = arrowWrappers.map((w) => w.querySelector('svg'));

  arrowElements.forEach((el) => {
    if (el) el.style.willChange = 'transform, opacity';
  });

  const gridRows = parseInt(footer?.dataset?.gridRows, 10) || 5;
  const gridCols = parseInt(footer?.dataset?.gridCols, 10) || 20;
  const totalArrows = Math.min(gridRows * gridCols, arrowElements.length);

  const springs = Array.from({ length: totalArrows }).map(() => ({ x: 0, y: 0, vx: 0, vy: 0 }));

  let cachedFooterRect = null;
  let cachedArrowCenters = [];

  function computeArrowCenters(rect) {
    const cellW = rect.width / gridCols;
    const cellH = rect.height / gridRows;

    return Array.from({ length: totalArrows }).map((_, i) => {
      const col = i % gridCols;
      const row = Math.floor(i / gridCols);
      return {
        x: rect.left + col * cellW + cellW / 2,
        y: rect.top + row * cellH + cellH / 2,
      };
    });
  }

  function updateGeometry(entries) {
    // ResizeObserver gives us the rect without forcing reflow
    const entry = entries[0];
    const rect = entry.target.getBoundingClientRect();

    cachedFooterRect = {
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height,
      right: rect.right,
      bottom: rect.bottom,
    };
    cachedArrowCenters = computeArrowCenters(cachedFooterRect);
  }

  // ResizeObserver fires on element resize AND position changes
  const resizeObserver = new ResizeObserver((entries) => {
    updateGeometry(entries);
  });
  resizeObserver.observe(footer);

  // Also update on scroll since position changes
  let scrollTicking = false;
  window.addEventListener('scroll', () => {
    if (scrollTicking) return;
    scrollTicking = true;
    requestAnimationFrame(() => {
      if (footer) {
        const rect = footer.getBoundingClientRect();
        cachedFooterRect = {
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height,
          right: rect.right,
          bottom: rect.bottom,
        };
        cachedArrowCenters = computeArrowCenters(cachedFooterRect);
      }
      scrollTicking = false;
    });
  }, { passive: true });

  let lastMouseEvent = { clientX: window.innerWidth / 2, clientY: window.innerHeight * 2 };
  let lastMouseMoveTime = performance.now();
  let animationRunning = false;
  let animationFrameId = null;

  const springStrength = 0.07;
  const damping = 0.8;
  const maxOffset = 40;
  const maxVelocity = 2.0;

  function computeArrowStates(mouseX, mouseY) {
    if (!cachedFooterRect) return [];

    const footerCenterX = cachedFooterRect.left + cachedFooterRect.width / 2;
    const footerCenterY = cachedFooterRect.top + cachedFooterRect.height / 2;
    const distanceThreshold = Math.max(cachedFooterRect.width, cachedFooterRect.height) * 0.75;
    const distanceToCenter = Math.hypot(mouseX - footerCenterX, mouseY - footerCenterY);

    const isNearFooter =
      mouseY > cachedFooterRect.top - 100 &&
      mouseY < cachedFooterRect.bottom + 100 &&
      mouseX > cachedFooterRect.left - 100 &&
      mouseX < cachedFooterRect.right + 100;

    const results = new Array(totalArrows);

    for (let i = 0; i < totalArrows; i++) {
      const center = cachedArrowCenters[i];
      if (!center) {
        results[i] = null;
        continue;
      }

      const arrowX = center.x;
      const arrowY = center.y;

      let targetX, targetY;
      if (distanceToCenter > distanceThreshold || !isNearFooter) {
        targetX = footerCenterX;
        targetY = footerCenterY;
      } else {
        targetX = mouseX;
        targetY = mouseY;
      }

      const dx = targetX - arrowX;
      const dy = targetY - arrowY;
      const angle = Math.atan2(dy, dx) * (180 / Math.PI);

      const spring = springs[i];
      const distance = Math.hypot(dx, dy) || 0.0001;

      const nudgeDirectionX = dx / distance;
      const nudgeDirectionY = dy / distance;
      const nudgeMagnitude = Math.min(distance * 0.05, maxOffset);
      const targetOffsetX = nudgeDirectionX * nudgeMagnitude;
      const targetOffsetY = nudgeDirectionY * nudgeMagnitude;
      const forceX = (targetOffsetX - spring.x) * springStrength;
      const forceY = (targetOffsetY - spring.y) * springStrength;

      spring.vx = spring.vx * damping + forceX;
      spring.vy = spring.vy * damping + forceY;

      const currentVelocity = Math.hypot(spring.vx, spring.vy);
      if (currentVelocity > maxVelocity) {
        const scaleFactor = maxVelocity / currentVelocity;
        spring.vx *= scaleFactor;
        spring.vy *= scaleFactor;
      }

      spring.x += spring.vx;
      spring.y += spring.vy;

      const posMag = Math.hypot(spring.x, spring.y);
      if (posMag > maxOffset) {
        const posScaleFactor = maxOffset / posMag;
        spring.x *= posScaleFactor;
        spring.y *= posScaleFactor;
      }

      const maxDistance = Math.hypot(cachedFooterRect.width, cachedFooterRect.height) / 1.5;
      const normalizedDistance = distance / maxDistance;
      const opacity = isNearFooter ? Math.max(0.2, 1 - Math.abs(normalizedDistance) * 2) : 0.2;

      results[i] = {
        transform: `translate3d(${spring.x}px, ${spring.y}px, 0) rotate(${angle}deg)`,
        opacity: opacity.toFixed(2),
        color: 'var(--color-link)',
      };
    }

    return results;
  }

  function applyArrowStates(states) {
    for (let i = 0; i < totalArrows; i++) {
      const arrow = arrowElements[i];
      const s = states[i];
      if (!arrow || !s) continue;
      arrow.style.transform = s.transform;
      arrow.style.opacity = s.opacity;
      arrow.style.color = s.color;
    }
  }

  function updateArrows(e) {
    if (!cachedFooterRect) return;

    const states = computeArrowStates(e.clientX, e.clientY);
    applyArrowStates(states);
  }

  function animateArrowsLoop() {
    const now = performance.now();
    const timeSinceLastMove = now - lastMouseMoveTime;

    if (timeSinceLastMove > 2000) {
      animationRunning = false;
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      return;
    }

    updateArrows(lastMouseEvent);
    animationFrameId = requestAnimationFrame(animateArrowsLoop);
  }

  function handleMouseMove(e) {
    lastMouseEvent = e;
    lastMouseMoveTime = performance.now();

    if (!animationRunning) {
      animationRunning = true;
      animationFrameId = requestAnimationFrame(animateArrowsLoop);
    }
  }

  document.addEventListener('mousemove', handleMouseMove);

  // Initial setup - do one read on load
  const initialRect = footer.getBoundingClientRect();
  cachedFooterRect = {
    left: initialRect.left,
    top: initialRect.top,
    width: initialRect.width,
    height: initialRect.height,
    right: initialRect.right,
    bottom: initialRect.bottom,
  };
  cachedArrowCenters = computeArrowCenters(cachedFooterRect);

  animationRunning = true;
  animationFrameId = requestAnimationFrame(animateArrowsLoop);

  window.addEventListener('beforeunload', () => {
    resizeObserver.disconnect();
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
  });
</script>
-->
